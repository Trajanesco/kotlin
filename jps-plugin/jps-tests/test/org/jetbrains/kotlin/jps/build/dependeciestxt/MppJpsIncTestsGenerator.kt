/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.jps.build.dependeciestxt

import java.io.File

/**
 * Utility for generating common/platform module stub contents based on it's dependencies.
 */
fun generateMppJpsIncTestCases(rootDir: String, dir: String) {
    File("$rootDir/$dir").listFiles { it: File -> it.isDirectory }.forEach {
        val dependenciesTxtFile = File(it, "dependencies.txt")
        if (dependenciesTxtFile.exists()) {
            val fileTitle = "$dir/${it.name}/dependencies.txt"
            val dependenciesTxt = DependenciesTxtBuilder().readFile(dependenciesTxtFile, fileTitle)

            MppJpsIncTestsGenerator(dependenciesTxtFile, dependenciesTxt, it).actualize()
        }
    }

    return
}

class MppJpsIncTestsGenerator(val txtFile: File, val txt: DependenciesTxt, val rootDir: File) {
    val generatedByComment =
        """//
          |// DON'T EDIT! This file is GENERATED by `MppJpsIncTestsGenerator` (called in generateTests)
          |// from `$txt`
          |//
          |
    """.trimMargin()

    val actualFiles = mutableSetOf(rootDir)

    val DependenciesTxt.Module.capitalName get() = name.capitalize()

    fun actualize() {
        txt.modules.forEach {
            if (it.edit) {
                TestCase("editing${it.capitalName}Kotlin").generateEditing(it, changeJavaClass = false)
            }

            if (it.editJvm && it.isJvmModule) {
                TestCase("editing${it.capitalName}Java").generateEditing(it, changeJavaClass = true)
            }

            if (it.editExpectActual && it.isCommonModule) {
                TestCase("editing${it.capitalName}ExpectActual").generateEditingExpectActual(it)
            }
        }

        val allFiles = rootDir.walkTopDown().toSet()
        val toDelete = allFiles.filter { !isSrc(it) && it !in actualFiles }
        for (file in toDelete) {
            println("File deleted: $file")
            file.deleteRecursively()
        }
    }

    private fun isSrc(it: File): Boolean {
        if (it.parentFile == rootDir) {
            if (it.name == "dependencies.txt") return true
        }
        if (it.name == "build.log") return true
        return false
    }

    /**
     * Set required content for [this] [File].
     * All files without actual content will be deleted in [actualize].
     */
    fun File.setFileContent(content: String) {
        addToActualWithParents()

        val wasExist = exists()
        if (!wasExist || readText() != content) {
            mkdirs()
            if (isDirectory) delete()
            writeText(content)

            if (wasExist) {
                println("File updated: $absolutePath")
            } else {
                println("File created: $absolutePath")
            }
        }
    }

    private fun File.addToActualWithParents() {
        var i = this
        while (i != rootDir) {
            actualFiles.add(i)
            i = i.parentFile ?: break
        }
    }

    data class ModuleContentSettings(
        val module: DependenciesTxt.Module,
        val serviceNameSuffix: String = "",
        val generateActualDeclarationsFor: List<DependenciesTxt.Module> = module.expectedBy.map { it.to },
        val generatePlatformDependent: Boolean = true,
        var generateKtFile: Boolean = true,
        var generateJavaFile: Boolean = true
    )

    open inner class TestCase(title: String) {
        private val dir = File(rootDir, title)
        private val modules = mutableMapOf<DependenciesTxt.Module, ModuleContentSettings>()

        var step = 1
        val steps = mutableListOf<String>()

        private inline fun step(name: String, body: () -> Unit) {
            body()
            steps.add(name)
            step++
        }

        var DependenciesTxt.Module.contentsSettings: ModuleContentSettings
            get() = modules.getOrPut(this) { ModuleContentSettings(this) }
            set(value) {
                modules[this] = value
            }

        fun generateEditing(module: DependenciesTxt.Module, changeJavaClass: Boolean) {
            generateBaseContent()

            // create new file with service implementation
            // don't create expect/actual functions (generatePlatformDependent = false)
            module.contentsSettings = ModuleContentSettings(
                module,
                serviceNameSuffix = "New",
                generatePlatformDependent = false,
                generateKtFile = !changeJavaClass,
                generateJavaFile = changeJavaClass
            )

            when {
                module.isCommonModule -> {
                    step("create new service") {
                        generateCommonFile(
                            module,
                            fileNameSuffix = ".new.$step"
                        )
                    }

                    step("edit new service") {
                        generateCommonFile(
                            module,
                            fileNameSuffix = ".touch.$step"
                        )
                    }

                    step("delete new service") {
                        serviceKtFile(
                            module,
                            fileNameSuffix = ".delete.$step"
                        ).setFileContent("")
                    }
                }
                else -> {
                    step("create new service") {
                        // generateKtFile event if changeJavaClass requested (for test calling java from kotlin)
                        val prevModuleContentsSettings = module.contentsSettings
                        module.contentsSettings = module.contentsSettings.copy(generateKtFile = true)


                        generatePlatformFile(
                            module,
                            fileNameSuffix = ".new.$step"
                        )

                        module.contentsSettings = prevModuleContentsSettings
                    }

                    step("edit new service") {
                        generatePlatformFile(
                            module,
                            fileNameSuffix = ".touch.$step"
                        )
                    }

                    step("delete new service") {
                        if (changeJavaClass) serviceJavaFile(module, fileNameSuffix = ".delete.$step").setFileContent("")

                        // kotlin file also created for testing java class
                        serviceKtFile(module, fileNameSuffix = ".delete.$step").setFileContent("")
                    }
                }
            }

            generateStepsTxt()
        }

        fun generateEditingExpectActual(commonModule: DependenciesTxt.Module) {
            generateBaseContent()
            check(commonModule.isCommonModule)
            val implModules = commonModule.usages.filter { it.expectedBy }.map { it.from }

            commonModule.contentsSettings = ModuleContentSettings(commonModule, serviceNameSuffix = "New")
            implModules.forEach { implModule ->
                implModule.contentsSettings = ModuleContentSettings(
                    implModule,
                    serviceNameSuffix = "New",
                    generateActualDeclarationsFor = listOf(commonModule)
                )
            }

            step("create new service in ${commonModule.name}") {
                generateCommonFile(commonModule, fileNameSuffix = ".new.$step")
            }

            implModules.forEach { implModule ->
                step("create new service in ${implModule.name}") {
                    generatePlatformFile(implModule, fileNameSuffix = ".new.$step")
                }
            }

            step("change new service in ${commonModule.name}") {
                generateCommonFile(commonModule, fileNameSuffix = ".touch.$step")
            }

            implModules.forEach { implModule ->
                if (implModule.isJvmModule) {
                    implModule.contentsSettings.generateKtFile = false
                    implModule.contentsSettings.generateJavaFile = true
                    step("change new service in ${implModule.name}: java") {
                        generatePlatformFile(implModule, fileNameSuffix = ".touch.$step")
                    }

                    implModule.contentsSettings.generateKtFile = true
                    implModule.contentsSettings.generateJavaFile = false
                    step("change new service in ${implModule.name}: kotlin") {
                        generatePlatformFile(implModule, fileNameSuffix = ".touch.$step")
                    }
                } else {
                    step("change new service in ${implModule.name}") {
                        generatePlatformFile(implModule, fileNameSuffix = ".touch.$step")
                    }
                }
            }

            implModules.forEach { implModule ->
                step("delete new service in ${implModule.name}") {
                    serviceKtFile(implModule, fileNameSuffix = ".delete.$step").setFileContent("")
                }
            }

            step("delete new service in ${commonModule.name}") {
                serviceKtFile(commonModule, fileNameSuffix = ".delete.$step").setFileContent("")
            }

            generateStepsTxt()
        }

        private fun generateStepsTxt() {
            File(dir, "steps.txt").setFileContent(steps.joinToString("\n"))
        }

        fun generateBaseContent() {
            dir.mkdir()
            File(dir, "dependencies.txt").setFileContent(
                generatedByComment + "\n" + txtFile.readText()
            )

            txt.modules.forEach {
                generateModuleContents(it)
            }

            val buildLog = File(dir, "build.log")
            if (!buildLog.exists()) {
                buildLog.writeText("")
            }
        }

        private fun generateModuleContents(module: DependenciesTxt.Module) {
            when {
                module.isCommonModule -> generateCommonFile(module)
                module.expectedBy.isEmpty() -> {
                    // regular module
                    generatePlatformFile(module)
                }
                else -> {
                    // common module platform implementation
                    module.expectedBy.forEach {
                        generatePlatformFile(module)
                    }
                }
            }
        }

        private val DependenciesTxt.Module.serviceName
            get() = "$capitalName${contentsSettings.serviceNameSuffix}"

        private val DependenciesTxt.Module.javaClassName
            get() = "${serviceName}JavaClass"

        private fun serviceKtFile(module: DependenciesTxt.Module, fileNameSuffix: String = ""): File {
            val suffix =
                if (module.isCommonModule) "${module.serviceName}Header"
                else "${module.name.capitalize()}${module.contentsSettings.serviceNameSuffix}Impl"

            return File(dir, "${module.indexedName}_service$suffix.kt$fileNameSuffix")
        }

        fun serviceJavaFile(module: DependenciesTxt.Module, fileNameSuffix: String = ""): File {
            return File(dir, "${module.indexedName}_${module.javaClassName}.java$fileNameSuffix")
        }

        private val DependenciesTxt.Module.platformDependentFunName: String
            get() {
                check(isCommonModule)
                return "${name}_platformDependent$serviceName"
            }

        private val DependenciesTxt.Module.platformIndependentFunName: String
            get() {
                check(isCommonModule)
                return "${name}_platformIndependent$serviceName"
            }

        private val DependenciesTxt.Module.platformOnlyFunName: String
            get() {
                // platformOnly fun names already unique, so no module name prefix required
                return "${name}_platformOnly${contentsSettings.serviceNameSuffix}"
            }

        private fun generateCommonFile(
            module: DependenciesTxt.Module,
            fileNameSuffix: String = ""
        ) {
            val settings = module.contentsSettings

            serviceKtFile(module, fileNameSuffix).setFileContent(buildString {
                @Suppress("CAST_NEVER_SUCCEEDS")
                this as StringBuilder // workaround for buildString resolution ambiguity

                appendln(generatedByComment)

                if (settings.generatePlatformDependent)
                    appendln("expect fun ${module.platformDependentFunName}(): String")

                appendln("fun ${module.platformIndependentFunName}() = \"common$fileNameSuffix\"")


                appendTestFun(module, settings)
            })
        }

        private fun generatePlatformFile(
            module: DependenciesTxt.Module,
            fileNameSuffix: String = ""
        ) {
            val isJvm = module.isJvmModule
            val settings = module.contentsSettings

            val javaClassName = module.javaClassName

            if (settings.generateKtFile) {
                serviceKtFile(module, fileNameSuffix).setFileContent(buildString {
                    @Suppress("CAST_NEVER_SUCCEEDS")
                    this as StringBuilder // workaround for buildString resolution ambiguity

                    appendln(generatedByComment)

                    if (settings.generatePlatformDependent) {
                        for (expectedBy in settings.generateActualDeclarationsFor) {
                            appendln(
                                "actual fun ${expectedBy.platformDependentFunName}(): String" +
                                        " = \"${module.name}$fileNameSuffix\""
                            )
                        }
                    }

                    appendln(
                        "fun ${module.platformOnlyFunName}()" +
                                " = \"${module.name}$fileNameSuffix\""
                    )

                    appendTestFun(module, settings)
                })
            }

            if (isJvm && settings.generateJavaFile) {
                serviceJavaFile(module, fileNameSuffix).setFileContent(
                    """
                    |$generatedByComment
                    |public class $javaClassName {
                    |    public String doStuff() {
                    |       return "${module.name}$fileNameSuffix";
                    |    }
                    |}
                    """.trimMargin()
                )
            }
        }

        // call all functions declared in this module and all of its dependencies recursively
        private fun StringBuilder.appendTestFun(
            module: DependenciesTxt.Module,
            settings: ModuleContentSettings
        ) {
            appendln()
            appendln("fun Test${module.serviceName}() {")

            val thisAndDependencies = mutableSetOf(module)
            module.collectDependenciesRecursivelyTo(thisAndDependencies)
            thisAndDependencies.forEach { thisOrDependent ->
                if (thisOrDependent.isCommonModule) {
                    appendln("  ${thisOrDependent.platformIndependentFunName}()")

                    if (settings.generatePlatformDependent) {
                        appendln("  ${thisOrDependent.platformDependentFunName}()")
                    }
                } else {
                    // platform module
                    appendln("  ${thisOrDependent.platformOnlyFunName}()")

                    if (thisOrDependent.isJvmModule && thisOrDependent.contentsSettings.generateJavaFile) {
                        appendln("  ${thisOrDependent.javaClassName}().doStuff()")
                    }
                }
            }

            appendln("}")
        }

        private fun DependenciesTxt.Module.collectDependenciesRecursivelyTo(
            collection: MutableCollection<DependenciesTxt.Module>,
            exportedOnly: Boolean = false
        ) {
            dependencies.forEach {
                if (!exportedOnly || it.effectivelyExported) {
                    val dependentModule = it.to
                    collection.add(dependentModule)
                    dependentModule.collectDependenciesRecursivelyTo(collection, exportedOnly = true)
                }
            }
        }
    }
}