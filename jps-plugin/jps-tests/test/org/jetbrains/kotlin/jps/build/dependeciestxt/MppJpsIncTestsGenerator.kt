/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.jps.build.dependeciestxt

import org.jetbrains.kotlin.util.capitalizeDecapitalize.capitalizeFirstLetter
import java.io.File

/**
 * Utility for generating common/platform module stub contents based on it's dependencies.
 *
 * Generated files:
 *  - for common modules:
 *    - `expect fun platformDependent(): String`
 *    - `fun platformIndependent() = "platformIndependent"`
 *    - `fun test() { /* platformDependent/platformIndependent calls for all dependencies */ }`
 *  - for platform modules:
 *    - `actual fun platformDependent() = "$platformName"`
 *    - `fun platformOnly() = "$platformName only"`
 *    - `fun test() { /* platformDependent/platformIndependent/platformOnly/JavaClass().doStuff() calls for all dependencies */ }`
 *  - for JVM:
 *    - `public class JavaClass { public String doStuff() { return "pJvm"; } }`
 *
 * Editions:
 *  - common module file with `newPlatformIndependentService.kt`
 *      - creating with contents `fun newPlatformIndependent() = "newPlatformIndependent"`
 *      - changing to `fun newPlatformIndependent() = "newPlatformIndependent changed"`
 *      - removing
 *  - platform module files with `newPlatformOnlyService.kt`
 *      - creating with contents `fun newPlatformOnly() = "newPlatformOnly"`
 *      - changing to `fun newPlatformOnly() = "newPlatformOnly changed"`
 *      - removing
 *  - expect/actual `newService.kt` (same as generated initially)
 *      - creating
 *      - changing implementations (adding " changed")
 *      - removing
 */
fun generateMppJpsIncTestCases(rootDir: String, dir: String) {
    File("$rootDir/$dir").listFiles { it: File -> it.isDirectory }.forEach {
        val dependenciesTxtFile = File(it, "dependencies.txt")
        if (dependenciesTxtFile.exists()) {
            val fileTitle = "$dir/${it.name}/dependencies.txt"
            val dependenciesTxt = DependenciesTxtBuilder().readFile(dependenciesTxtFile, fileTitle)

            MppJpsIncTestsGenerator(dependenciesTxtFile, dependenciesTxt, it).actualize()
        }
    }

    return
}

class MppJpsIncTestsGenerator(val txtFile: File, val txt: DependenciesTxt, val rootDir: File) {
    val generatedByComment =
        """//
          |// DON'T EDIT! This file is GENERATED by `MppJpsIncTestsGenerator` (runs by generateTests)
          |// from `$txt`
          |//
          |
    """.trimMargin()

    val actualFiles = mutableSetOf(rootDir)

    val DependenciesTxt.Module.capitalName get() = name.capitalizeFirstLetter()

    fun actualize() {
        TestCase("initial").generateBaseContent()

        txt.modules.forEach {
            if (it.generateEditingTests) {
                TestCase("editing${it.capitalName}Kotlin").generateEditing(it, changeJavaClass = false)

                when {
                    it.isJvmModule -> TestCase("editing${it.capitalName}Java").generateEditing(it, changeJavaClass = true)
                    it.isCommonModule -> TestCase("editing${it.capitalName}ExpectActual").generateEditingExpectActual(it)
                }
            }
        }

        val allFiles = rootDir.walkTopDown().toSet()
        val toDelete = allFiles.filter { !isSrc(it) && it !in actualFiles }
        for (file in toDelete) {
            println("File deleted: $file")
            file.deleteRecursively()
        }
    }

    private fun isSrc(it: File): Boolean {
        if (it.parentFile == rootDir) {
            if (it.name == "dependencies.txt") return true
        }
        if (it.name == "build.log") return true
        return false
    }

    fun File.setFileContent(content: String) {
        addToActualWithParents()

        val wasExist = exists()
        if (!wasExist || readText() != content) {
            mkdirs()
            if (isDirectory) delete()
            writeText(content)

            if (wasExist) {
                println("File updated: $absolutePath")
            } else {
                println("File created: $absolutePath")
            }
        }
    }

    private fun File.addToActualWithParents() {
        var i = this
        while (i != rootDir) {
            actualFiles.add(i)
            i = i.parentFile ?: break
        }
    }

    open inner class TestCase(title: String) {
        private val dir = File(rootDir, title)

        fun generateEditing(module: DependenciesTxt.Module, changeJavaClass: Boolean) {
            generateBaseContent()
            when {
                module.isCommonModule -> {
                    generateCommonFile(
                        module,
                        platformDependent = false,
                        serviceName = "New",
                        fileNameSuffix = ".new.1"
                    )
                    generateCommonFile(
                        module,
                        platformDependent = false,
                        serviceName = "New",
                        fileNameSuffix = ".touch.2"
                    )

                    serviceKtFile(
                        module,
                        serviceName = "New",
                        fileNameSuffix = ".delete.3"
                    ).setFileContent("")
                }
                else -> {
                    generatePlatformFile(
                        module,
                        generatePlatformDependent = false,
                        ktFile = true, // for testing calling java from kotlin
                        javaFile = changeJavaClass,
                        serviceName = "New",
                        fileNameSuffix = ".new.1"
                    )

                    generatePlatformFile(
                        module,
                        generatePlatformDependent = false,
                        ktFile = !changeJavaClass,
                        javaFile = changeJavaClass,
                        serviceName = "New",
                        fileNameSuffix = ".touch.2"
                    )

                    if (changeJavaClass) serviceJavaFile(module, serviceName = "New", fileNameSuffix = ".delete.3").setFileContent("")

                    // kotlin file also created for testing java class
                    serviceKtFile(module, serviceName = "New", fileNameSuffix = ".delete.3").setFileContent("")
                }
            }
        }

        fun generateEditingExpectActual(module: DependenciesTxt.Module) {
            generateBaseContent()
            check(module.isCommonModule)
            generateCommonFile(module, serviceName = "New", fileNameSuffix = ".new.1")
            generateCommonFile(module, serviceName = "New", fileNameSuffix = ".touch.2")
            serviceKtFile(module, serviceName = "New", fileNameSuffix = ".delete.3").setFileContent("")

            module.usages.filter { it.expectedBy }.forEach {
                val implModule = it.from
                generatePlatformFile(implModule, serviceName = "New", fileNameSuffix = ".new.1")
                generatePlatformFile(implModule, serviceName = "New", fileNameSuffix = ".touch.2")
                serviceKtFile(implModule, serviceName = "New", fileNameSuffix = ".delete.3").setFileContent("")
            }
        }

        fun generateBaseContent() {
            dir.mkdir()
            File(dir, "dependencies.txt").setFileContent(
                generatedByComment + "\n" + txtFile.readText()
            )

            txt.modules.forEach {
                generateModuleContents(it)
            }

            val buildLog = File(dir, "build.log")
            if (!buildLog.exists()) {
                buildLog.writeText("")
            }
        }

        private fun generateModuleContents(module: DependenciesTxt.Module) {
            when {
                module.isCommonModule -> generateCommonFile(module)
                module.expectedBy.isEmpty() -> {
                    // regular module
                    generatePlatformFile(module)
                }
                else -> {
                    // common module platform implementation
                    module.expectedBy.forEach {
                        generatePlatformFile(module)
                    }
                }
            }
        }

        private fun serviceName(commonModule: DependenciesTxt.Module, suffix: String) =
            commonModule.capitalName + suffix

        private fun javaClassName(module: DependenciesTxt.Module, serviceName: String) =
            "${module.capitalName}${serviceName}JavaClass"

        fun serviceKtFile(module: DependenciesTxt.Module, serviceName: String = "", fileNameSuffix: String = ""): File {
            val suffix = if (module.isCommonModule) "Header" else "Impl"
            return File(dir, "${module.name}_service$serviceName$suffix.kt$fileNameSuffix")
        }

        fun serviceJavaFile(module: DependenciesTxt.Module, serviceName: String = "", fileNameSuffix: String = ""): File {
            val javaClassName = javaClassName(module, serviceName)
            return File(dir, "${module.name}_$javaClassName.java$fileNameSuffix")
        }

        private fun generateCommonFile(
            module: DependenciesTxt.Module,
            platformDependent: Boolean = true,
            serviceName: String = "",
            fileNameSuffix: String = ""
        ) {
            val uniqServiceName = module.capitalName + serviceName
            serviceKtFile(module, uniqServiceName, fileNameSuffix).setFileContent(buildString {
                appendln(generatedByComment)

                if (platformDependent)
                    appendln("expect fun ${module.name}_platformDependent${serviceName(module, serviceName)}(): String")

                appendln("fun ${module.name}_platformIndependent${serviceName(module, serviceName)}() = \"common$fileNameSuffix\"")

                appendln()
                appendln("fun ${module.name}Test() {")

                if (platformDependent) {
                    for (expectedBy in module.dependencies) {
                        appendln("  ${expectedBy.to.name}_platformIndependent${serviceName(expectedBy.to, serviceName)}()")

                        if (platformDependent)
                            appendln("  ${expectedBy.to.name}_platformDependent${serviceName(expectedBy.to, serviceName)}()")
                    }
                }

                appendln("}")
            })
        }

        private fun generatePlatformFile(
            module: DependenciesTxt.Module,
            generatePlatformDependent: Boolean = true,
            ktFile: Boolean = true,
            javaFile: Boolean = true,
            serviceName: String = "",
            fileNameSuffix: String = ""
        ) {
            val isJvm = module.isJvmModule

            val javaClassName = javaClassName(module, serviceName)

            if (ktFile) {
                serviceKtFile(module, serviceName, fileNameSuffix).setFileContent(buildString {
                    appendln(generatedByComment)

                    if (generatePlatformDependent) {
                        for (expectedBy in module.expectedBy) {
                            appendln(
                                "actual fun ${expectedBy.to.name}_platformDependent${serviceName(
                                    expectedBy.to,
                                    serviceName
                                )}(): String = \"${module.name}$fileNameSuffix\""
                            )
                        }
                    }

                    appendln("fun ${module.name}_platformOnly$serviceName() = \"${module.name}$fileNameSuffix\"")

                    appendln()
                    appendln("fun ${module.name}Test$serviceName() {")

                    // call all functions declared in this module and all of its dependencies recursively
                    val thisAndDependencies = mutableSetOf(module)
                    module.collectDependenciesRecursivelyTo(thisAndDependencies)
                    thisAndDependencies.forEach { thisOrDependent ->
                        if (thisOrDependent.isCommonModule) {
                            appendln("  ${thisOrDependent.name}_platformIndependent${serviceName(thisOrDependent, serviceName)}()")

                            if (generatePlatformDependent) {
                                appendln("  ${thisOrDependent.name}_platformDependent${serviceName(thisOrDependent, serviceName)}()")
                            }
                        } else {
                            // platform module
                            appendln("  ${thisOrDependent.name}_platformOnly$serviceName()")

                            if (thisOrDependent.isJvmModule) {
                                appendln("  ${javaClassName(thisOrDependent, serviceName)}().doStuff()")
                            }
                        }
                    }

                    appendln("}")
                })
            }

            if (isJvm && javaFile) {
                serviceJavaFile(module, serviceName, fileNameSuffix).setFileContent(
                    """
                    |$generatedByComment
                    |public class $javaClassName {
                    |    public String doStuff() {
                    |       return "${module.name}$fileNameSuffix";
                    |    }
                    |}
                    """.trimMargin()
                )
            }
        }

        private fun DependenciesTxt.Module.collectDependenciesRecursivelyTo(collection: MutableCollection<DependenciesTxt.Module>) {
            dependencies.forEach {
                val dependentModule = it.to
                collection.add(dependentModule)
                dependentModule.collectDependenciesRecursivelyTo(collection)
            }
        }
    }
}