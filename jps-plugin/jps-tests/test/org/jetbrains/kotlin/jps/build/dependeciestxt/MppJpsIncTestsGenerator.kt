/*
 * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license
 * that can be found in the license/LICENSE.txt file.
 */

package org.jetbrains.kotlin.jps.build.dependeciestxt

import org.jetbrains.kotlin.util.capitalizeDecapitalize.capitalizeFirstLetter
import java.io.File

/**
 * Utility for generating common/platform module stub contents based on it's dependencies.
 *
 * Generated files:
 *  - for common modules:
 *    - `expect fun platformDependent(): String`
 *    - `fun platformIndependent() = "platformIndependent"`
 *    - `fun test() { /* platformDependent/platformIndependent calls for all dependencies */ }`
 *  - for platform modules:
 *    - `actual fun platformDependent() = "$platformName"`
 *    - `fun platformOnly() = "$platformName only"`
 *    - `fun test() { /* platformDependent/platformIndependent/platformOnly/JavaClass().doStuff() calls for all dependencies */ }`
 *  - for JVM:
 *    - `public class JavaClass { public String doStuff() { return "pJvm"; } }`
 *
 * Editions:
 *  - common module file with `newPlatformIndependentService.kt`
 *      - creating with contents `fun newPlatformIndependent() = "newPlatformIndependent"`
 *      - changing to `fun newPlatformIndependent() = "newPlatformIndependent changed"`
 *      - removing
 *  - platform module files with `newPlatformOnlyService.kt`
 *      - creating with contents `fun newPlatformOnly() = "newPlatformOnly"`
 *      - changing to `fun newPlatformOnly() = "newPlatformOnly changed"`
 *      - removing
 *  - expect/actual `newService.kt` (same as generated initially)
 *      - creating
 *      - changing implementations (adding " changed")
 *      - removing
 */
fun generateMppJpsIncTestCases(rootDir: String, dir: String) {
    File("$rootDir/$dir").listFiles { it: File -> it.isDirectory }.forEach {
        val dependenciesTxtFile = File(it, "dependencies.txt")
        if (dependenciesTxtFile.exists()) {
            val fileTitle = "$dir/${it.name}/dependencies.txt"
            val dependenciesTxt = DependenciesTxtBuilder().readFile(dependenciesTxtFile, fileTitle)

            MppJpsIncTestsGenerator(dependenciesTxtFile, dependenciesTxt, it).actualize()
        }
    }

    return
}

class MppJpsIncTestsGenerator(val txtFile: File, val txt: DependenciesTxt, val rootDir: File) {
    val generatedByComment =
        """//
          |// DON'T EDIT! This file is GENERATED by `MppJpsIncTestsGenerator` (runs by generateTests)
          |// from `$txt`
          |//
          |
    """.trimMargin()

    val actualFiles = mutableSetOf(rootDir)

    val DependenciesTxt.Module.capitalName get() = name.capitalizeFirstLetter()

    fun actualize() {
        TestCase("initial").generateBaseContent()

        txt.modules.forEach {
            if (it.generateEditingTests) {
                TestCase("editing${it.capitalName}Kotlin").generateEditing(it, changeJavaClass = false)

                when {
                    it.isJvmModule -> TestCase("editing${it.capitalName}Java").generateEditing(it, changeJavaClass = true)
                    it.isCommonModule -> TestCase("editing${it.capitalName}ExpectActual").generateEditingExpectActual(it)
                }
            }
        }

        val allFiles = rootDir.walkTopDown().toSet()
        val toDelete = allFiles.filter { !isSrc(it) && it !in actualFiles }
        for (file in toDelete) {
            println("File deleted: $file")
            file.deleteRecursively()
        }
    }

    private fun isSrc(it: File): Boolean {
        if (it.parentFile == rootDir) {
            if (it.name == "dependencies.txt") return true
        }
        if (it.name == "build.log") return true
        return false
    }

    fun File.setFileContent(content: String) {
        addToActualWithParents()

        val wasExist = exists()
        if (!wasExist || readText() != content) {
            mkdirs()
            if (isDirectory) delete()
            writeText(content)

            if (wasExist) {
                println("File updated: $absolutePath")
            } else {
                println("File created: $absolutePath")
            }
        }
    }

    private fun File.addToActualWithParents() {
        var i = this
        while (i != rootDir) {
            actualFiles.add(i)
            i = i.parentFile ?: break
        }
    }

    data class ModuleContentSettings(
        val serviceNameSuffix: String = "",
        val generatePlatformDependent: Boolean = true,
        val generateKtFile: Boolean = true,
        val generateJavaFile: Boolean = true
    )

    open inner class TestCase(title: String) {
        private val dir = File(rootDir, title)
        private val modules = mutableMapOf<DependenciesTxt.Module, ModuleContentSettings>()

        var DependenciesTxt.Module.contentsSettings: ModuleContentSettings
            get() = modules.getOrPut(this) { ModuleContentSettings() }
            set(value) {
                modules[this] = value
            }

        fun generateEditing(module: DependenciesTxt.Module, changeJavaClass: Boolean) {
            generateBaseContent()

            // create new file with service implementation
            // don't create expect/actual functions (generatePlatformDependent = false)
            module.contentsSettings = ModuleContentSettings(
                serviceNameSuffix = "New",
                generatePlatformDependent = false,
                generateKtFile = !changeJavaClass,
                generateJavaFile = changeJavaClass
            )

            when {
                module.isCommonModule -> {
                    generateCommonFile(
                        module,
                        fileNameSuffix = ".new.1"
                    )
                    generateCommonFile(
                        module,
                        fileNameSuffix = ".touch.2"
                    )

                    serviceKtFile(
                        module,
                        fileNameSuffix = ".delete.3"
                    ).setFileContent("")
                }
                else -> {
                    generatePlatformFile(
                        module,
                        fileNameSuffix = ".touch.2"
                    )

                    // generateKtFile event if changeJavaClass requested (for test calling java from kotlin)
                    module.contentsSettings = module.contentsSettings.copy(generateKtFile = true)

                    generatePlatformFile(
                        module,
                        fileNameSuffix = ".new.1"
                    )


                    if (changeJavaClass) serviceJavaFile(module, fileNameSuffix = ".delete.3").setFileContent("")

                    // kotlin file also created for testing java class
                    serviceKtFile(module, fileNameSuffix = ".delete.3").setFileContent("")
                }
            }
        }

        fun generateEditingExpectActual(module: DependenciesTxt.Module) {
            generateBaseContent()
            check(module.isCommonModule)
            val impls = module.usages.filter { it.expectedBy }.map { it.from }

            module.contentsSettings = ModuleContentSettings(serviceNameSuffix = "New")
            impls.forEach {
                it.contentsSettings = ModuleContentSettings(serviceNameSuffix = "New")
            }

            generateCommonFile(module, fileNameSuffix = ".new.1")
            generateCommonFile(module, fileNameSuffix = ".touch.2")
            serviceKtFile(module, fileNameSuffix = ".delete.3").setFileContent("")

            impls.forEach {
                generatePlatformFile(it, fileNameSuffix = ".new.1")
                generatePlatformFile(it, fileNameSuffix = ".touch.2")
                serviceKtFile(it, fileNameSuffix = ".delete.3").setFileContent("")
            }
        }

        fun generateBaseContent() {
            dir.mkdir()
            File(dir, "dependencies.txt").setFileContent(
                generatedByComment + "\n" + txtFile.readText()
            )

            txt.modules.forEach {
                generateModuleContents(it)
            }

            val buildLog = File(dir, "build.log")
            if (!buildLog.exists()) {
                buildLog.writeText("")
            }
        }

        private fun generateModuleContents(module: DependenciesTxt.Module) {
            when {
                module.isCommonModule -> generateCommonFile(module)
                module.expectedBy.isEmpty() -> {
                    // regular module
                    generatePlatformFile(module)
                }
                else -> {
                    // common module platform implementation
                    module.expectedBy.forEach {
                        generatePlatformFile(module)
                    }
                }
            }
        }

        private val DependenciesTxt.Module.serviceName
            get() = "$capitalName${contentsSettings.serviceNameSuffix}"

        private val DependenciesTxt.Module.javaClassName
            get() = "${serviceName}JavaClass"

        private fun serviceKtFile(module: DependenciesTxt.Module, fileNameSuffix: String = ""): File {
            val suffix =
                if (module.isCommonModule) "${module.serviceName}Header"
                else {
                    // Impl file names already unique, so no module name prefix required
                    "${module.contentsSettings.serviceNameSuffix}Impl"
                }

            return File(dir, "${module.name}_service$suffix.kt$fileNameSuffix")
        }

        fun serviceJavaFile(module: DependenciesTxt.Module, fileNameSuffix: String = ""): File {
            return File(dir, "${module.name}_${module.javaClassName}.java$fileNameSuffix")
        }

        private val DependenciesTxt.Module.platformDependentFunName: String
            get() {
                check(isCommonModule)
                return "${name}_platformDependent$serviceName"
            }

        private val DependenciesTxt.Module.platformIndependentFunName: String
            get() {
                check(isCommonModule)
                return "${name}_platformIndependent$serviceName"
            }

        private val DependenciesTxt.Module.platformOnlyFunName: String
            get() {
                // platformOnly fun names already unique, so no module name prefix required
                return "${name}_platformOnly${contentsSettings.serviceNameSuffix}"
            }

        private fun generateCommonFile(
            module: DependenciesTxt.Module,
            fileNameSuffix: String = ""
        ) {
            val settings = module.contentsSettings

            serviceKtFile(module, fileNameSuffix).setFileContent(buildString {
                @Suppress("CAST_NEVER_SUCCEEDS")
                this as StringBuilder // workaround for buildString resolution ambiguity

                appendln(generatedByComment)

                if (settings.generatePlatformDependent)
                    appendln("expect fun ${module.platformDependentFunName}(): String")

                appendln("fun ${module.platformIndependentFunName}() = \"common$fileNameSuffix\"")


                appendTestFun(module, settings)
            })
        }

        private fun generatePlatformFile(
            module: DependenciesTxt.Module,
            fileNameSuffix: String = ""
        ) {
            val isJvm = module.isJvmModule
            val settings = module.contentsSettings

            val javaClassName = module.javaClassName

            if (settings.generateKtFile) {
                serviceKtFile(module, fileNameSuffix).setFileContent(buildString {
                    @Suppress("CAST_NEVER_SUCCEEDS")
                    this as StringBuilder // workaround for buildString resolution ambiguity

                    appendln(generatedByComment)

                    if (settings.generatePlatformDependent) {
                        for (expectedBy in module.expectedBy) {
                            appendln(
                                "actual fun ${expectedBy.to.platformDependentFunName}(): String" +
                                        " = \"${module.name}$fileNameSuffix\""
                            )
                        }
                    }

                    appendln(
                        "fun ${module.platformOnlyFunName}()" +
                                " = \"${module.name}$fileNameSuffix\""
                    )

                    appendTestFun(module, settings)
                })
            }

            if (isJvm && settings.generateJavaFile) {
                serviceJavaFile(module, fileNameSuffix).setFileContent(
                    """
                    |$generatedByComment
                    |public class $javaClassName {
                    |    public String doStuff() {
                    |       return "${module.name}$fileNameSuffix";
                    |    }
                    |}
                    """.trimMargin()
                )
            }
        }

        // call all functions declared in this module and all of its dependencies recursively
        private fun StringBuilder.appendTestFun(
            module: DependenciesTxt.Module,
            settings: ModuleContentSettings
        ) {
            appendln()
            appendln("fun Test${module.serviceName}() {")

            val thisAndDependencies = mutableSetOf(module)
            module.collectDependenciesRecursivelyTo(thisAndDependencies)
            thisAndDependencies.forEach { thisOrDependent ->
                if (thisOrDependent.isCommonModule) {
                    appendln("  ${thisOrDependent.platformIndependentFunName}()")

                    if (settings.generatePlatformDependent) {
                        appendln("  ${thisOrDependent.platformDependentFunName}()")
                    }
                } else {
                    // platform module
                    appendln("  ${thisOrDependent.platformOnlyFunName}()")

                    if (thisOrDependent.isJvmModule && thisOrDependent.contentsSettings.generateJavaFile) {
                        appendln("  ${thisOrDependent.javaClassName}().doStuff()")
                    }
                }
            }

            appendln("}")
        }

        private fun DependenciesTxt.Module.collectDependenciesRecursivelyTo(collection: MutableCollection<DependenciesTxt.Module>) {
            dependencies.forEach {
                val dependentModule = it.to
                collection.add(dependentModule)
                dependentModule.collectDependenciesRecursivelyTo(collection)
            }
        }
    }
}